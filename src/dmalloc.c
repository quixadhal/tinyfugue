#if USE_DMALLOC

#include "config.h"
#include <stdio.h>
#include "port.h"
#include "malloc.h"
/* #include "tf.h" */
#include "signals.h"

#define size_t long unsigned
#define DEBUG_MALLOCS_TRACE

#define DEBUG_MALLOCS_RCHECK
/* #define DEBUG_MALLOCS_PRINT */
/* #define DEBUG_MALLOCS_WASTE_MEMORY */
/* #define DEBUG_MALLOCS_SLOW */

void *dmalloc(void *md, long unsigned size, const char *file, const int line);
void *dcalloc(void *md, long unsigned size, const char *file, const int line);
void *drealloc(void *md, void *ptr, long unsigned size, const char *file, const int line);
void     dfree(void *md, void *ptr, const char *file, const int line);
void     check_all_magic(const char *file, int line);


/* written by dmoore 12/26/91, to reduce the MALLOC, FREE, etc macros
   into subroutines. */
/* edited by kkeys, to work better with tf. */

/* The trick is, we will always ask malloc for the requested memory
   PLUS enough memory to hold this stucture at the beginning.  Then
   we will fill in the appropriate fields, and return the pointer
   just past the structure to the caller.  The magic numbers will
   hopefully be useful to track illegal frees/reallocs.  By keeping
   a linked list of the things we have malloced, as well as the file
   and line number where they were malloced, memory leaks can be
   tracked. */

/* You want the size of this structure to be a multiple of your
   alignment size.  That way, when the real malloc returns something aligned
   the result these routines return will be aligned.  It is fine as
   currently stated if your architecture has sizeof(int) = sizeof(ptr) = 4.
   And you align to 2 or 4 byte words.  Since this is common, it's
   probably right for you. */

size_t total = 0;

struct debug_malloc_info {
    void *magic1;
    const char *file;
    int line;
    const char *ffile;
    int fline;
#ifdef DEBUG_MALLOCS_RCHECK
    size_t size;
    size_t asize;
#endif /* DEBUG_MALLOCS_RCHECK */
#ifdef DEBUG_MALLOCS_TRACE
    struct debug_malloc_info *next, *prev;
#endif /* DEBUG_MALLOCS_TRACE */
    void *magic2;
};

/* Two magic numbers, one to specify a valid pointer that our malloc
   has generated.  The other set on freed objects.  Note that the freed
   information can get lost, though, because a later call to malloc might
   reuse that space. */
#define MAGIC_USED  (void*)0x600DC0DEul
#define MAGIC_FREED (void*)0xDEADBEEFul

/* Magic numbers used to fill out freed/uninitialized memory space.
 * Use 0 to try to make things dereference them badly.  Use a large character
 * to flush out things which check if 0 and then use it anyway.
 */
#define FREE_FILLER (char)0xBB
#define MALLOC_FILLER (char)0xDD

struct debug_malloc_info *info_head = 0, *info2_head = 0;


static int align_size(int size)
{
    if (!(size % 4)) return size;
    else return size + 4 - (size % 4);
}


/* Verify that the pointer we've just recieved is one generated by an
   earlier call to malloc.  This is done by checking for some magic
   numbers that have been stored just in front of the pointer the user has. */
static void check_magic(const void *cp, const char *file, const int line)
{
    struct debug_malloc_info *info, *info2;
    char buf[1024];
    
    if (!cp) {
	core("REALLOC/FREE: null pointer.", file, line, 0);
	/* NEVER REACHED */
    }
    
    info = (struct debug_malloc_info *) cp;
    info--;
    
    if ((info->magic1 == MAGIC_FREED) || (info->magic2 == MAGIC_FREED)) {
	sprintf(buf, "REALLOC/FREE: pointer already freed at %s:%d "
	    "(allocated at %s:%d).",
	    info->ffile, info->fline, info->file, info->line);
	core(buf, file, line, 0);
	/* NEVER REACHED */
    }
    
    if ((info->magic1 != MAGIC_USED) || (info->magic2 != MAGIC_USED)) {
	core("REALLOC/FREE: illegal pointer.", file, line, 0);
	/* NEVER REACHED */
    }
    
#ifdef DEBUG_MALLOCS_RCHECK
    info2 = (struct debug_malloc_info *) (((char *) cp) + info->asize);
    
    if ((info2->magic1 != info->magic1) ||
	(info2->magic2 != info->magic2) ||
	(info2->file != info->file) ||
	(info2->line != info->line) ||
	(info2->ffile != info->ffile) ||
	(info2->fline != info->fline) ||
	(info2->size != info->size)) {
	sprintf(buf, "REALLOC/FREE: range check failed. Allocated at %.15s %d.",
            info->file, info->line);
	core(buf, file, line, 0);
	/* NEVER REACHED */
    }
#endif /* DEBUG_MALLOCS_RCHECK */
}


/* This stores the appropriate magic numbers for a new memory allocation
   and chains this node into a linked list of all of the malloced nodes. */
static void set_magic(void *cp, const char *file, const int line, const size_t size)
{
    struct debug_malloc_info *info, *info2;
    
    info = (struct debug_malloc_info *) cp;
    info->magic1 = MAGIC_USED;
    info->file = file;
    info->line = line;
    info->ffile = NULL;
    info->fline = 0;
    info->magic2 = MAGIC_USED;
    
#ifdef DEBUG_MALLOCS_TRACE
    /* Chain it into the linked list. */
    info->next = info_head;
    info->prev = 0;
    if (info_head) info_head->prev = info;
    info_head = info;
#endif /* DEBUG_MALLOCS_TRACE */
    
#ifdef DEBUG_MALLOCS_RCHECK
    info->size = size;
    info->asize = align_size(size);
    
    info2 = (struct debug_malloc_info *) (((char *) cp) + info->asize);
    info2++;
    
    info2->next = info2_head;
    info2->prev = 0;
    if (info2_head) info2_head->prev = info2;
    info2_head = info2;

    info2->magic1 = info2->magic2 = MAGIC_USED;
    info2->file = file;
    info2->line = line;
    info2->ffile = NULL;
    info2->fline = 0;
    info2->size = size;
#endif /* DEBUG_MALLOCS_RCHECK */
}


static void reset_size(void *cp, const size_t size)
{
    struct debug_malloc_info *info, *info2, *old2;
    
    info = (struct debug_malloc_info *) cp;
    info--;
#ifdef DEBUG_MALLOCS_RCHECK
    old2  = (struct debug_malloc_info *) (((char*)cp) + info->asize);
    info->size = size;
    info->asize = align_size(size);
    info2 = (struct debug_malloc_info *) (((char*)cp) + info->asize);
    
    memmove(info2, old2, sizeof(struct debug_malloc_info));
    info2->size = size; 
    if (info2->next) info2->next->prev = info2;
    if (info2->prev) info2->prev->next = info2;
    else info2_head = info2;
#endif /* DEBUG_MALLOCS_RCHECK */
    if (info->next) info->next->prev = info;
    if (info->prev) info->prev->next = info;
    else info_head = info;
}


/* This routine removes the node from the list of malloced memories,
   and resets the magic numbers so we can hopefully detect illegal frees
   to the same address again.  It also zeroes out the memory that was
   allocated, hopeing to flush out problems. */
static void clear_node(void *cp, const char *file, const int line)
{
    struct debug_malloc_info *info, *info2;
    char *ptr;
    
    info = (struct debug_malloc_info *) cp;
    info--;
    total -= info->size;
#ifdef DEBUG_MALLOCS_PRINT
    fprintf(stderr, "%6u: %10s %5d: free    %6u (%10s %5d)\n",
        total, file, line, info->size, info->file, info->line);
#endif
    
#ifdef DEBUG_MALLOCS_TRACE
    /* Remove it from the linked list. */
    if (info->next) info->next->prev = info->prev;
    if (info == info_head) {
	info_head = info->next;
    } else {
	info->prev->next = info->next;
    }
    info->next = 0;
    info->prev = 0;
#endif /* DEBUG_MALLOCS_TRACE */
    
    /* Set magic so we know if they try to free it again! */
    info->magic1 = info->magic2 = MAGIC_FREED;
    info->ffile = file;
    info->fline = line;

    for (ptr = (char *) cp; ptr < (char *)cp + info->asize; ptr++)
	*ptr = FREE_FILLER;
    
#ifdef DEBUG_MALLOCS_RCHECK
    info2 = (struct debug_malloc_info *) (((char *) cp) + info->asize);

    if (info2->next) info2->next->prev = info2->prev;
    if (info2 == info2_head) {
	info2_head = info2->next;
    } else {
	info2->prev->next = info2->next;
    }
    
    info2->magic1 = info2->magic2 = MAGIC_FREED;
    info2->ffile = file;
    info2->fline = line;
#endif /* DEBUG_MALLOCS_RCHECK */
}


void *drealloc(void *md, void *cp, size_t size,
    const char *file, const int line)
{
    struct debug_malloc_info *result, *info;

    /* ANSI C treats realloc(NULL, size) like malloc(size) */
    if (!cp) return dmalloc(md, size, file, line);

    /* realloc will copy over the header struct for us. */
    info = (struct debug_malloc_info *) cp;
    info--;

    total += size - info->size;
#ifdef DEBUG_MALLOCS_PRINT
    fprintf(stderr, "%6u: %10s %5d: realloc %6u (%10s %5d, %6u)\n",
        total, file, line, size, info->file, info->line, info->size);
#endif

    check_all_magic(file, line);
    check_magic(cp, file, line);
    
    /* size = align_size(size); */
    
    if (size == 0) {
	fprintf(stderr, "REALLOC: tried to realloc(0) at %s:%d.", file, line);
	dfree(md, cp, file, line);  /* Know it's not null from check_magic. */
	return NULL;
    }

#ifndef DEBUG_MALLOCS_RCHECK
    result = mrealloc(md, info,
        align_size(size) + sizeof(struct debug_malloc_info));
#else
    result = mrealloc(md, info,
        align_size(size) + 2*sizeof(struct debug_malloc_info));
#endif /* DEBUG_MALLOCS_RCHECK */
    
    if (result == NULL) return NULL;

    result++;
    reset_size(result, size);
    return (void *) result;
}


void *dmalloc(void *md, size_t size, const char *file, const int line)
{
    struct debug_malloc_info *result;
    char *ptr;
    
    total += size;
#ifdef DEBUG_MALLOCS_PRINT
    fprintf(stderr, "%6u: %10s %5d: malloc  %6u\n", total, file, line, size);
#endif
    check_all_magic(file, line);
    /* size = align_size(size); */
    
    if (size == 0) {
	fprintf(stderr, "MALLOC: tried to malloc(0) at %s:%d.", file, line);
	return NULL;
    }
    
#ifndef DEBUG_MALLOCS_RCHECK
    result = (struct debug_malloc_info *)
        mmalloc(md, align_size(size) + sizeof(struct debug_malloc_info));
#else
    result = mmalloc(md, align_size(size) + 2*sizeof(struct debug_malloc_info));
#endif /* DEBUG_MALLOCS_RCHECK */
    
    if (result == NULL) return NULL;
    
    set_magic(result, file, line, size);
    result++;
    /* Fill in uninitialized memory to catch incorrect use. */
    for (ptr = (char *)result; ptr < (char *)result + result[-1].asize; ptr++)
	*ptr = MALLOC_FILLER;
    return (void *) result;
}


void dfree(void *md, void *cp, const char *file, const int line)
{
    struct debug_malloc_info *arg;
    
    check_all_magic(file, line);
    check_magic(cp, file, line);
    
    clear_node(cp, file, line);
    
    arg = (struct debug_malloc_info *) cp;
    arg--;
    
#ifndef DEBUG_MALLOCS_WASTE_MEMORY
    /* free the memory, unless we have chosen not to free anything,
       which is the only guaranteed way to detect multiple frees of the same
       data, and will most likely waste memory like mad. */
    mfree(md, (void *) arg);
#endif /* DEBUG_MALLOCS_WASTE_MEMORY */
}


void *dcalloc(void *md, size_t size, const char *file, const int line)
{
    void *result;

    if ((result = dmalloc(md, size, file, line)))
        memset(result, '\0', size);
    return result;
}


void debug_mstats(const char *s)
{
#ifdef DEBUG_MALLOCS_TRACE
    struct debug_malloc_info *temp, *prev = NULL;
    unsigned int counter = 0;
    size_t size = 0;
    int i, j;
    char c;
    
    if (info_head) {
        fprintf(stderr, "(%s): unfreed memory allocated by:\n", s);
        for (temp = info_head; temp; prev = temp, temp = temp->next) {
            check_magic(temp + 1, "debug_mstats", 0);
            fprintf(stderr, "%10s %5d: %6lu",
                temp->file ? temp->file : "NULL", temp->line, temp->size);
            if (prev != temp->prev) fputs("   temp->prev != prev", stderr);
	    fputs("  \"", stderr);
	    for (i = j = 0; i < temp->size; i++, j++) {
		if (j >= 40) {
		    fputs("...", stderr);
		    break;
		}
		c = ((char*)(temp+1))[i];
		if (isprint(c)) {
		    fputc(c, stderr);
		} else {
		    fprintf(stderr, "\\%03o", (unsigned char)c);
		    j += 3;
		}
	    }
	    fputc('\"', stderr);
            fputc('\n', stderr);
            size += temp->size;
	    if (counter++ > 1000) {
	        fprintf(stderr,
                    "possible loop, stopping after %lu bytes in %u pointers.\n",
                    size, counter);
	        break;
	    }
        }
    }
    fprintf(stderr, "(%s): %lu unfreed bytes in %u pointers.\n",
        s, total, counter);
#endif /* DEBUG_MALLOCS_TRACE */
}

void check_all_magic(const char *file, int line)
{
#ifdef DEBUG_MALLOCS_TRACE
#ifdef DEBUG_MALLOCS_SLOW
    struct debug_malloc_info *temp = NULL, *prev = NULL;
    struct debug_malloc_info *temp2 = NULL, *prev2 = NULL;
    int count = 10000;
    
    temp = info_head;
#ifdef DEBUG_MALLOCS_RCHECK
    temp2 = info2_head;
    while (count && temp && temp2) {
        if (prev2 != temp2->prev) {
	    printf("prev2 != temp2->prev\n");
            if (prev != temp->prev) printf("prev != temp->prev\n");
	    break;
	}
#else
    while (count && temp) {
#endif
        if (prev != temp->prev) {
	    printf("prev != temp->prev\n");
	    break;
	}
        check_magic(temp + 1, file, line);
        prev = temp;
        temp = temp->next;
#ifdef DEBUG_MALLOCS_RCHECK
        prev2 = temp2;
        temp2 = temp2->next;
#endif
    }
    if (!count) core("check_all_magic:  loop", file, line, 0);
    if (temp || temp2) core("check_all_malloc: len(1) <> len(2)", file, line, 0);
#endif
#else
    /* return 1; */
#endif /* DEBUG_MALLOCS_TRACE */
}

#endif /* USE_DMALLOC */
